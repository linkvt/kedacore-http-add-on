package config

import (
	"time"

	"github.com/caarlos0/env/v11"
)

// Serving is configuration for how the interceptor serves the proxy
// and admin server
type Serving struct {
	// WatchNamespace is the namespace to watch for new HTTPScaledObjects.
	// Leave this empty to watch HTTPScaledObjects in all namespaces.
	WatchNamespace string `env:"KEDA_HTTP_WATCH_NAMESPACE" envDefault:""`
	// ProxyPort is the port that the public proxy should run on
	ProxyPort int `env:"KEDA_HTTP_PROXY_PORT,required"`
	// AdminPort is the port that the internal admin server should run on.
	// This is the server that the external scaler will issue metrics
	// requests to
	AdminPort int `env:"KEDA_HTTP_ADMIN_PORT,required"`
	// CacheSyncPeriod is the time interval for the controller-runtime cache to resync.
	// TODO: consider removing this to use the default value, otherwise align the env var name
	CacheSyncPeriod time.Duration `env:"KEDA_HTTP_SCALER_CONFIG_MAP_INFORMER_RSYNC_PERIOD" envDefault:"60m"`
	// The interceptor has an internal process that periodically fetches the state
	// of endpoints that is running the servers it forwards to.
	//
	// This is the interval (in milliseconds) representing how often to do a fetch
	// TODO: this is actually the informer resync period, not a poll interval, default is too aggressive
	EndpointsCachePollIntervalMS int `env:"KEDA_HTTP_ENDPOINTS_CACHE_POLLING_INTERVAL_MS" envDefault:"1000"`
	// ProxyTLSEnabled is a flag to specify whether the interceptor proxy should
	// be running using a TLS enabled server
	ProxyTLSEnabled bool `env:"KEDA_HTTP_PROXY_TLS_ENABLED" envDefault:"false"`
	// TLSCertPath is the path to read the certificate file from for the TLS server
	TLSCertPath string `env:"KEDA_HTTP_PROXY_TLS_CERT_PATH" envDefault:"/certs/tls.crt"`
	// TLSKeyPath is the path to read the private key file from for the TLS server
	TLSKeyPath string `env:"KEDA_HTTP_PROXY_TLS_KEY_PATH" envDefault:"/certs/tls.key"`
	// TLSCertStorePaths is a comma separated list of paths to read the certificate/key pairs for the TLS server
	TLSCertStorePaths string `env:"KEDA_HTTP_PROXY_TLS_CERT_STORE_PATHS" envDefault:""`
	// TLSSkipVerify is a boolean flag to specify whether the interceptor should skip TLS verification for upstreams
	TLSSkipVerify bool `env:"KEDA_HTTP_PROXY_TLS_SKIP_VERIFY" envDefault:"false"`
	// TLSPort is the port that the server should serve on if TLS is enabled
	TLSPort int `env:"KEDA_HTTP_PROXY_TLS_PORT" envDefault:"8443"`
	// ProfilingAddr if not empty, pprof will be available on this address, assuming host:port here
	ProfilingAddr string `env:"PROFILING_BIND_ADDRESS" envDefault:""`
	// EnableColdStartHeader enables/disables the X-KEDA-HTTP-Cold-Start response header
	EnableColdStartHeader bool `env:"KEDA_HTTP_ENABLE_COLD_START_HEADER" envDefault:"true"`
	// LogRequests enables/disables logging of incoming requests
	LogRequests bool `env:"KEDA_HTTP_LOG_REQUESTS" envDefault:"false"`
}

// MustParseServing parses standard configs and returns the
// newly created config. It panics if parsing fails.
func MustParseServing() Serving {
	return env.Must(env.ParseAs[Serving]())
}
